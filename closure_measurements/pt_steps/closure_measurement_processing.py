import sys
import ast
import posixpath
import multiprocessing
import numpy as np

import limatix.timestamp
from closure_measurements import process_dic

from closure_measurements.process_dic import load_dgs,Calc_CTODs,CalcInitialModel,EvalEffectiveTip,InitializeFullModel

from limatix import dc_value
from limatix.dc_value import numericunitsvalue as numericunitsv
from limatix.dc_value import hrefvalue as hrefv
from limatix.dc_value import xmltreevalue as xmltreev

def run(_xmldoc,_element,
        _dest_href,
        _inputfilename,
        dc_measnum_int,
        dc_scan_outdic_href,
        dc_coordinatetransform,
        dc_spcYoungsModulus_numericunits,
        dic_span_int=20,
        dic_smoothing_window_int=3,
        dic_tip_tolerance_numericunits=numericunitsv(100e-6,"m"),
        dc_symmetric_cod_bool=True,
        debug_bool=False):
    
    # Non-adjustable parameters
    nominal_length=2e-3 # nominal crack length, for nondimensional normalization
    #nominal_modulus=100.0e9 # nominal modulus
    nominal_stress=50e6 # nominal stress
    
    num_output_loads = 15
    
    
    # Coordinates generated by
    # this processtrak step shall be in stitched image
    # coordinates (see ExtractAndSitchOpticalImageJ.py _aligned_measnum.dgs and RegisterOpticalData.py)

    # To get fiducial coordinates, add xshift and yshift.
    
    YoungsModulus = dc_spcYoungsModulus_numericunits.value("Pa")
    
    xshift = numericunitsv.fromxml(_xmldoc, _xmldoc.xpathsinglecontext(dc_coordinatetransform, 'dc:translation/dc:xtranslation')).value('m')
    yshift = numericunitsv.fromxml(_xmldoc, _xmldoc.xpathsinglecontext(dc_coordinatetransform, 'dc:translation/dc:ytranslation')).value('m')
    
    #keypoints = _opxmldoc.xpathcontext(dc_crackpath, 'dc:segment/dc:keypoint')

    tip_tolerance = dic_tip_tolerance_numericunits.value("m")
    
    (dic_dx,dic_dy,
     dic_nx,dic_ny,
     XRangeSize,
     nloads,
     Xinivec,Xposvecs,
     load1,load2,u_disps,v_disps,
     ROI_out_arrays,
     CrackCenterX,TipCoords1,TipCoords2,
     ROI_dic_yminidx,ROI_dic_ymaxidx,
     relshift_firstimg_lowerleft_corner_x_ref,
     relshift_firstimg_lowerleft_corner_x_diff,
     relshift_firstimg_lowerleft_corner_y_ref,
     relshift_firstimg_lowerleft_corner_y_diff) = load_dgs(dc_scan_outdic_href.getpath())



    CTODs = Calc_CTODs(dic_nx,nloads,XRangeSize,Xposvecs,v_disps,ROI_out_arrays,ROI_dic_yminidx,ROI_dic_ymaxidx,dic_span,dic_smoothing_window)

        (InitialModels_side1,
     InitialCoeffs_side1,
     Error_side1,
     npoints_side1,
     XPositions_side1,
     CTODValues_side1) = CalcInitialModel(nloads,CTODs,
                                          load1,load2,
                                          Xposvecs,CrackCenterX,
                                          dic_dy,dic_span,
                                          Symmetric_COD,2,YoungsModulus,
                                          relshift_firstimg_lowerleft_corner_x_ref=relshift_firstimg_lowerleft_corner_x_ref,
                                          nominal_length=nominal_length,nominal_stress=nominal_stress,
                                          doplots=True)


    (InitialModels_side2,
     InitialCoeffs_side2,
     Error_side2,
     npoints_side2,
     YPositions_side2,
     CTODValues_side2) = CalcInitialModel(nloads,CTODs,
                                          load1,load2,
                                          Xposvecs,CrackCenterX,
                                          dic_dy,dic_span,
                                          Symmetric_COD,2,YoungsModulus,
                                          relshift_firstimg_lowerleft_corner_x_ref=relshift_firstimg_lowerleft_corner_x_ref,
                                          nominal_length=nominal_length,nominal_stress=nominal_stress,
                                          doplots=True)


    (minload_side1,maxload_side1,seed_param_side1) = InitializeFullModel(load1,load2,InitialCoeffs_side1,Error_side1,npoints_side1,XPositions_side1,CTODValues_side1,InitialModels_side1,CrackCenterX,tip_tolerance,Symmetric_COD,side=1,doplots=True)

    (minload_side2,maxload_side2,seed_param_side2) = InitializeFullModel(load1,load2,InitialCoeffs_side2,Error_side2,npoints_side2,XPositions_side2,CTODValues_side2,InitialModels_side2,CrackCenterX,tip_tolerance,Symmetric_COD,side=2,doplots=True)


    minload=np.min(load1[~np.isnan(load1)].ravel())
    maxload=np.max(load1[~np.isnan(load1)].ravel())

    output_loads=np.linspace(minload,maxload,num_output_loads)
    tippos_side1 = EvalEffectiveTip(minload,maxload,seed_param_side1,output_loads)
    tippos_side2 = EvalEffectiveTip(minload,maxload,seed_param_side2,output_loads)

    closureprofile_side1 = xmldoc.xmldoc.newdoc("dc:closureprofile",nsmap={"dc":"http://limatix.org/datacollect"})
    for loadcnt in range(num_output_loads):
        newel = closureprofile_side1.addsimpleelement(closureprofile_side1.getroot(),"dc:tippos",(tippos_side1[loadcnt],"m"))
        closureprofile_side1.setattr(newel,"load_pascals",str(output_loads[loadcnt]))
        pass
    closureprofile_side1_tree = xmltreev(closureprofile_side1)
        
    closureprofile_side2 = xmldoc.xmldoc.newdoc("dc:closureprofile",nsmap={"dc":"http://limatix.org/datacollect"})
    for loadcnt in range(num_output_loads):
        newel = closureprofile_side2.addsimpleelement(closureprofile_side2.getroot(),"dc:tippos",(tippos_side2[loadcnt],"m"))
        closureprofile_side2.setattr(newel,"load_pascals",str(output_loads[loadcnt]))
        pass
    closureprofile_side2_tree = xmltreev(closureprofile_side2)
    
    return [
        (("dc:closureprofile",{"side": "1"}),closureprofile_side1_tree),
        (("dc:closureprofile",{"side": "2"}),closureprofile_side2_tree),
    ]
