import sys
import ast
import copy
import posixpath
import multiprocessing
import numpy as np

from matplotlib import pyplot as pl
from matplotlib.gridspec import GridSpec
from matplotlib.widgets import Slider

import limatix.timestamp
from closure_measurements import process_dic

from closure_measurements.process_dic import load_dgs,Calc_CTODs,CalcInitialModel,EvalEffectiveTip,InitializeFullModel,CalcFullModel,calculate_closureprofile

from limatix import dc_value
from limatix import xmldoc
from limatix.dc_value import numericunitsvalue as numericunitsv
from limatix.dc_value import hrefvalue as hrefv
from limatix.dc_value import xmltreevalue as xmltreev
from limatix.dc_value import arrayvalue as arrayv

def run(_xmldoc,_element,
        _dest_href,
        _inputfilename,
        dc_scan_outdic_href,
        dc_crackcenterx_numericunits,
        dc_crackcentery_numericunits,
        dc_measnum_int,
        dc_coordinatetransform,
        dc_spcYoungsModulus_numericunits,
        dc_specimen_str,
        dc_dic_span_int=20,
        dc_dic_smoothing_window_int=3,
        # NOTE: Default tip tolerance is smaller here than in command line version
        # because typically this is used with data that has gone through a registration
        # process and therefore has tighter tolerances
        dc_dic_tip_tolerance_numericunits=numericunitsv(50e-6,"m"),
        dc_min_dic_points_per_meter_numericunits=numericunitsv(40000,"1/m"),
        dc_symmetric_cod_bool=True):

    # Non-adjustable parameters
    nominal_length=2e-3 # nominal crack length, for nondimensional normalization
    #nominal_modulus=100.0e9 # nominal modulus
    nominal_stress=50e6 # nominal stress
    
    num_output_loads = 15
    
    # Coordinates generated by
    # this processtrak step shall be in stitched image
    # coordinates (see ExtractAndSitchOpticalImageJ.py _aligned_measnum.dgs and RegisterOpticalData.py)

    min_dic_points_per_meter=dc_min_dic_points_per_meter_numericunits.value("1/m")

    # To get fiducial coordinates, add xshift and yshift.
    
    YoungsModulus = dc_spcYoungsModulus_numericunits.value("Pa")
    
    xshift = numericunitsv.fromxml(_xmldoc, _xmldoc.xpathsinglecontext(dc_coordinatetransform, 'dc:translation/dc:xtranslation')).value('m')
    yshift = numericunitsv.fromxml(_xmldoc, _xmldoc.xpathsinglecontext(dc_coordinatetransform, 'dc:translation/dc:ytranslation')).value('m')
    
    #keypoints = _opxmldoc.xpathcontext(dc_crackpath, 'dc:segment/dc:keypoint')

    tip_tolerance = dc_dic_tip_tolerance_numericunits.value("m")


        
    (dic_dx,dic_dy,
     dic_nx,dic_ny,
     XRangeSize,
     nloads,
     Xinivec,Xposvecs,
     load1,load2,u_disps,v_disps,
     ROI_out_arrays,
     CrackCenterCoords,TipCoords1,TipCoords2,
     ROI_dic_yminidx,ROI_dic_ymaxidx,
     relshift_middleimg_lowerleft_corner_x_ref,
     relshift_middleimg_lowerleft_corner_x_diff,
     relshift_middleimg_lowerleft_corner_y_ref,
     relshift_middleimg_lowerleft_corner_y_diff) = load_dgs(dc_scan_outdic_href.getpath())



    CTODs = Calc_CTODs(dic_nx,nloads,XRangeSize,Xposvecs,v_disps,ROI_out_arrays,ROI_dic_yminidx,ROI_dic_ymaxidx,dc_dic_span_int,dc_dic_smoothing_window_int)

    tippos1=None
    tippos2=None
    if TipCoords1 is not None: # If crack has a side 1 (left)
        (InitialModels_side1,
         InitialCoeffs_side1,
         Error_side1,
         npoints_side1,
         XPositions_side1,
         CTODValues_side1) = CalcInitialModel(nloads,CTODs,
                                              load1,load2,
                                              Xposvecs,CrackCenterCoords,
                                              dic_dy,dc_dic_span_int,
                                              dc_symmetric_cod_bool,1,YoungsModulus,
                                              relshift_middleimg_lowerleft_corner_x_ref=relshift_middleimg_lowerleft_corner_x_ref,
                                              nominal_length=nominal_length,nominal_stress=nominal_stress,
                                              doplots=True)
        tippos1=TipCoords1[0]
        pass


    if TipCoords2 is not None: # if crack has a side 2 (right)
        (InitialModels_side2,
         InitialCoeffs_side2,
         Error_side2,
         npoints_side2,
         XPositions_side2,
         CTODValues_side2) = CalcInitialModel(nloads,CTODs,
                                              load1,load2,
                                              Xposvecs,CrackCenterCoords,
                                              dic_dy,dc_dic_span_int,
                                              dc_symmetric_cod_bool,2,YoungsModulus,
                                              relshift_middleimg_lowerleft_corner_x_ref=relshift_middleimg_lowerleft_corner_x_ref,
                                              nominal_length=nominal_length,nominal_stress=nominal_stress,
                                              doplots=False)
        tippos2=TipCoords2[0]
        pass


    minload_side1=None
    maxload_side1=None

    minload_side2=None
    maxload_side2=None

    if TipCoords1 is not None: # If crack has a side 1 (left)
        (minload_side1,maxload_side1,seed_param_side1,lowest_avg_load_used_side1,fm_plots_side1,fm_plotdata_side1) = InitializeFullModel(load1,load2,TipCoords1,TipCoords2,InitialCoeffs_side1,Error_side1,npoints_side1,XPositions_side1,CTODValues_side1,InitialModels_side1,CrackCenterCoords,tip_tolerance,min_dic_points_per_meter,dc_symmetric_cod_bool,side=1,doplots=False)
        (xt_unwrapped_side1,avg_load_unwrapped_side1,xt_vals_side1,avg_load_vals_side1)=fm_plotdata_side1
        pass

    if TipCoords2 is not None: # if crack has a side 2 (right)
        (minload_side2,maxload_side2,seed_param_side2,lowest_avg_load_used_side2,fm_plots_side2,fm_plotdata_side2) = InitializeFullModel(load1,load2,TipCoords1,TipCoords2,InitialCoeffs_side2,Error_side2,npoints_side2,XPositions_side2,CTODValues_side2,InitialModels_side2,CrackCenterCoords,tip_tolerance,min_dic_points_per_meter,dc_symmetric_cod_bool,side=2,doplots=True)
        (xt_unwrapped_side2,avg_load_unwrapped_side2,xt_vals_side2,avg_load_vals_side2)=fm_plotdata_side2
        pass


    
    load_tip_model_side1_el=_xmldoc.xpathsinglecontext(_element,"dc:load_tip_model[@side='1']",default=None)
    load_tip_model_side2_el=_xmldoc.xpathsinglecontext(_element,"dc:load_tip_model[@side='2']",default=None)

    if load_tip_model_side1_el is not None:
        load_tip_model_side1=arrayv.fromxml(_xmldoc,load_tip_model_side1_el).value()
        model_params_side1=load_tip_model_side1[:5]
        minload_side1=load_tip_model_side1[5]
        maxload_side1=load_tip_model_side1[6]
        tippos1 = load_tip_model_side1[7]

        pass


    if load_tip_model_side2_el is not None:
        load_tip_model_side2=arrayv.fromxml(_xmldoc,load_tip_model_side2_el).value()
        model_params_side2=load_tip_model_side2[:5]
        minload_side2=load_tip_model_side2[5]
        maxload_side2=load_tip_model_side2[6]
        tippos2 = load_tip_model_side2[7]

        pass

    tipfig = pl.figure()
    gs=GridSpec(5,2,height_ratios=[4,1,1,1,1])
    ax=pl.subplot(gs[0,0:2])

    if load_tip_model_side1_el is not None:
        s1c1=Slider(pl.subplot(gs[1,0]),'side1c1',(tippos1-5e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+5e-3)*1e3,valinit=model_params_side1[0]*1e3)
        s1c2=Slider(pl.subplot(gs[2,0]),'side1c2',(tippos1-5e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+5e-3)*1e3,valinit=model_params_side1[1]*1e3)
        s1c3=Slider(pl.subplot(gs[3,0]),'side1c3',(tippos1-5e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+5e-3)*1e3,valinit=model_params_side1[2]*1e3)
        s1c4=Slider(pl.subplot(gs[4,0]),'side1c4',(tippos1-5e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+5e-3)*1e3,valinit=model_params_side1[3]*1e3)
        pass

    if load_tip_model_side2_el is not None:
        s2c1=Slider(pl.subplot(gs[1,1]),'side2c1',(tippos1-1e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+1e-3)*1e3,valinit=model_params_side2[0]*1e3)
        s2c2=Slider(pl.subplot(gs[2,1]),'side2c2',(tippos1-1e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+1e-3)*1e3,valinit=model_params_side2[1]*1e3)
        s2c3=Slider(pl.subplot(gs[3,1]),'side2c3',(tippos1-1e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+1e-3)*1e3,valinit=model_params_side2[2]*1e3)
        s2c4=Slider(pl.subplot(gs[4,1]),'side2c4',(tippos1-1e-3)*1e3,(dc_crackcenterx_numericunits.value("m")+1e-3)*1e3,valinit=model_params_side2[3]*1e3)
        pass
    
    def drawfunc():
        pl.figure(tipfig.number)
        pl.sca(ax)
        ax.clear()
        (output_loads_side1,tippos_side1,output_loads_side2,tippos_side2) = calculate_closureprofile(minload_side1,maxload_side1,minload_side2,maxload_side2,num_output_loads,model_params_side1,model_params_side2,tippos1,tippos2)
        if load_tip_model_side1_el is not None:
            pl.plot(tippos_side1*1e3,output_loads_side1/1e6,'-')
            pl.plot(xt_unwrapped_side1*1e3,avg_load_unwrapped_side1/1e6,'o')
            pl.plot(xt_vals_side1*1e3,avg_load_vals_side1/1e6,'x')           
            pass
        
        if load_tip_model_side2_el is not None:
            pl.plot(tippos_side2*1e3,output_loads_side2/1e6,'-')
            pl.plot(xt_unwrapped_side2*1e3,avg_load_unwrapped_side2/1e6,'o')
            pl.plot(xt_vals_side2*1e3,avg_load_vals_side2/1e6,'x')           
            pass
        pl.grid()
        pl.xlabel('Tip position (relative to stitched image, mm)')
        pl.ylabel('Applied load (MPa)')
        #pl.legend(('Side 1','Side 2'),loc="best")
        pl.title(dc_specimen_str)
        pass


    
    def update(val):
        if load_tip_model_side1_el is not None:
            model_params_side1[0] = s1c1.val/1e3
            model_params_side1[1] = s1c2.val/1e3
            model_params_side1[2] = s1c3.val/1e3
            model_params_side1[3] = s1c4.val/1e3
            pass
        if load_tip_model_side2_el is not None:
            model_params_side2[0] = s2c1.val/1e3
            model_params_side2[1] = s2c2.val/1e3
            model_params_side2[2] = s2c3.val/1e3
            model_params_side2[3] = s2c4.val/1e3
            pass
        drawfunc()
        pl.draw()
        pass

    if load_tip_model_side1_el is not None:
        s1c1.on_changed(update)
        s1c2.on_changed(update)
        s1c3.on_changed(update)
        s1c4.on_changed(update)
        pass

    if load_tip_model_side2_el is not None:
        s2c1.on_changed(update)
        s2c2.on_changed(update)
        s2c3.on_changed(update)
        s2c4.on_changed(update)
        pass


    drawfunc()

    print("Use the sliders to adjust the fit. Close window when done.")
    pl.show()
    

    (output_loads_side1,tippos_side1,output_loads_side2,tippos_side2) =  process_dic.calculate_closureprofile(minload_side1,maxload_side1,minload_side2,maxload_side2,num_output_loads,model_params_side1,model_params_side2,tippos1,tippos2)

    if load_tip_model_side1_el is not None:
        # If crack has a side 1 (left)
        # Elements of the load_tip_model are the four spline coefficients, followed by c5, followed by minimum load, followed by maximum load
        # These numbers, with the exception of c5 can be used to calculate tip position given load by EvalEffectiveTip()
        new_load_tip_model_side1 = arrayv(np.concatenate((model_params_side1,(minload_side1,maxload_side1,tippos1))))
        pass
        
    if load_tip_model_side2_el is not None:
        # if crack has a side 2 (right)
        new_load_tip_model_side2 = arrayv(np.concatenate((model_params_side2,(minload_side2,maxload_side2,tippos2))))
        pass
    

    outdic_basename = posixpath.splitext(dc_scan_outdic_href.get_bare_quoted_filename())[0]
    if posixpath.splitext(outdic_basename)[1]==".dgs":  # Would happen if what we just split off was a .bz2, .gz, etc.
        outdic_basename = posixpath.splitext(outdic_basename)[0]
        pass


    closureprofile_href = hrefv(outdic_basename+"_closureprofile_manual.csv",contexthref=_dest_href)

    process_dic.save_closureprofile(closureprofile_href.getpath(),output_loads_side1,tippos_side1,output_loads_side2,tippos_side2)


    pl.figure(tipfig.number)
    closureprofile_manual_plot_href = hrefv(outdic_basename+"_closureprofile_manual.png",contexthref=_dest_href)
    pl.savefig(closureprofile_manual_plot_href.getpath(),dpi=300,transparent=True)

                         
    pl.close('all')
    ret = [
        #(("dc:closureprofile",{"side": "1"}),closureprofile_side1_tree),
        #(("dc:closureprofile",{"side": "2"}),closureprofile_side2_tree),
        ("dc:closureprofile_manual",closureprofile_href),
        ("dc:closureprofile_manual_plot",closureprofile_manual_plot_href),
    ]
                                          
    if load_tip_model_side1_el is not None:
        # Elements of the load_tip_model are the four spline coefficients, followed by c5, followed by minimum load, followed by maximum load
        # These numbers, with the exception of c5 can be used to calculate tip position given load by EvalEffectiveTip()
        ret.append( (("dc:load_tip_manual_model",{"side": "1"}),new_load_tip_model_side1) )
                                          
        pass

    if load_tip_model_side2_el is not None:
        ret.append( (("dc:load_tip_manual_model",{"side": "2"}),new_load_tip_model_side2) )
        pass
    
    return ret
